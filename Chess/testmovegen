void allAttacked() {
	cmove = 0;
	uint8_t kpos = 0;
	for (uint8_t i = 0; i < SPACES; ++i) {
		threatened[WHITE][i] = 0;
		threatened[BLACK][i] = 0;
	}
	if (turn) {
		for (uint8_t from = 0; from < SPACES; ++from) {
			if (grid[from]) {
				if (grid[from] == KING) { kpos = from; }
				else threatenedSquares(from);
			}
		}
		threatenedSquares(kpos);
	}
	else {
		for (uint8_t from = 0; from < SPACES; ++from) {
			if (grid[from]) {
				if (grid[from] == -KING) { kpos = from; }
				else threatenedSquares(from);
			}
		}
		threatenedSquares(kpos);
	}
}

void threatenedSquares(uint8_t from) {
	int8_t i;
	bool us = (grid[from] > 0) ? WHITE : BLACK;
	bool enemy = (us) ? BLACK : WHITE;
	switch (grid[from]) {
	case KING:
		if (WHITE == turn) {
			if ((from + 9) % WIDTH > from % WIDTH && from < 55) {
				++threatened[WHITE][from + 9];
				if (!threatened[BLACK][from + 9] && grid[from + 9] <= 0) {
					if (!grid[from + 9]) { possiblemoves[cmove] = move(from, from + 9, STANDARD); }
					else { possiblemoves[cmove] = move(from, from + 9, CAPTURE); }
					++cmove;
				}
			}
			if ((from + 1) % WIDTH > from % WIDTH) {
				++threatened[WHITE][from + 1];
				if (!threatened[BLACK][from + 1] && grid[from + 1] <= 0) {
					if (!grid[from + 1]) { possiblemoves[cmove] = move(from, from + 1, STANDARD); }
					else { possiblemoves[cmove] = move(from, from + 1, CAPTURE); }
					++cmove;
				}
			}
			if ((from - 9) % WIDTH < from % WIDTH && from >= 9) {
				++threatened[WHITE][from - 9];
				if (!threatened[BLACK][from - 9] && grid[from - 9] <= 0) {
					if (!grid[from - 9]) { possiblemoves[cmove] = move(from, from - 9, STANDARD); }
					else { possiblemoves[cmove] = move(from, from - 9, CAPTURE); }
					++cmove;
				}
			}
			if ((from - 1) % WIDTH < from % WIDTH && from >= 1) {
				++threatened[WHITE][from - 1];
				if (!threatened[BLACK][from - 1] && grid[from - 1] <= 0) {
					if (!grid[from - 1]) { possiblemoves[cmove] = move(from, from - 1, STANDARD); }
					else { possiblemoves[cmove] = move(from, from - 1, CAPTURE); }
					++cmove;
				}
			}
			if ((from + 7) % WIDTH < from % WIDTH && from < 57) {
				++threatened[WHITE][from + 7];
				if (!threatened[BLACK][from + 7] && grid[from + 7] >= 0) {
					if (!grid[from + 7]) { possiblemoves[cmove] = move(from, from + 7, STANDARD); }
					else { possiblemoves[cmove] = move(from, from + 7, CAPTURE); }
					++cmove;
				}
			}
			if (from + 8 < SPACES) {
				++threatened[WHITE][from + 8];
				if (!threatened[BLACK][from + 8] && grid[from + 8] <= 0) {
					if (!grid[from + 8]) { possiblemoves[cmove] = move(from, from + 8, STANDARD); }
					else { possiblemoves[cmove] = move(from, from + 8, CAPTURE); }
					++cmove;
				}
			}
			if ((from - 7) % WIDTH > from % WIDTH && from >= 7) {
				++threatened[WHITE][from - 7];
				if (!threatened[BLACK][from - 7] && grid[from - 7] <= 0) {
					if (!grid[from - 7]) { possiblemoves[cmove] = move(from, from - 7, STANDARD); }
					else { possiblemoves[cmove] = move(from, from - 7, CAPTURE); }
					++cmove;
				}
			}
			if (from >= 8) {
				++threatened[WHITE][from - 8];
				if (!threatened[BLACK][from - 8] && grid[from - 8] <= 0) {
					if (!grid[from - 8]) { possiblemoves[cmove] = move(from, from - 8, STANDARD); }
					else { possiblemoves[cmove] = move(from, from - 8, CAPTURE); }
					++cmove;
				}
			}
			if (from == 60 && !grid[from + 1] && !grid[from + 2] && !threatened[BLACK][from] && !threatened[BLACK][from + 1] && !threatened[BLACK][from + 2]) {
				for (i = 0; i < cturn; i++) {
					if (mHist[i].getFrom() == from || mHist[i].getFrom() == from + 3 || mHist[i].getTo() == from + 3) { break; }
				}
				if (i == cturn) {
					possiblemoves[cmove] = move(from, from + 2, KCASTLE);
				}
			}
			if (from == 60 && !grid[from - 1] && !grid[from - 2] && !grid[from - 3] && !threatened[BLACK][from] && !threatened[BLACK][from - 1] && !threatened[BLACK][from - 2] && !threatened[BLACK][from - 3]) {
				for (i = 0; i < cturn; ++i) {
					if (mHist[i].getFrom() == from || mHist[i].getFrom() == from - 4 || mHist[i].getTo() == from - 4) { break; }
				}
				if (i == cturn) {
					possiblemoves[cmove] = move(from, from + 2, QCASTLE);
				}
			}
		}
		else {
			if ((from + 9) % WIDTH > from % WIDTH && from < 55) { ++threatened[WHITE][from + 9]; }
			if ((from + 1) % WIDTH > from % WIDTH) { ++threatened[WHITE][from + 1]; }
			if ((from - 9) % WIDTH < from % WIDTH && from > 8) { ++threatened[WHITE][from - 9]; }
			if ((from - 1) % WIDTH < from % WIDTH && from > 0) { ++threatened[WHITE][from - 1]; }
			if ((from + 7) % WIDTH < from % WIDTH && from < 57) { ++threatened[WHITE][from + 7]; }
			if (from + 8 < SPACES) { ++threatened[WHITE][from + 8]; }
			if ((from - 7) % WIDTH > from % WIDTH && from > 6) { ++threatened[WHITE][from - 7]; }
			if (from >= 8) { ++threatened[WHITE][from - 8]; }
		}
		return;
	case PAWN:
		if (WHITE == turn) {
			if (from % WIDTH) {
				++threatened[WHITE][from + NORTH - 1];
				if (grid[from + NORTH - 1] < 0) {
					if (from > 15) { possiblemoves[cmove] = move(from, from + NORTH - 1, CAPTURE); }
					else { possiblemoves[cmove] = move(from, from + NORTH - 1, QPROMOTEC); }
					++cmove;
				}
			}
			if (from % WIDTH != 7) {
				++threatened[WHITE][from + NORTH + 1];
				if (grid[from + NORTH + 1] < 0) {
					if (from > 15) { possiblemoves[cmove] = move(from, from + NORTH + 1, CAPTURE); }
					else { possiblemoves[cmove] = move(from, from + NORTH + 1, QPROMOTEC); }
					++cmove;
				}
			}
			if (mHist[cturn - 1].getFlags() == DOUBLEPUSH && ((mHist[cturn - 1].getTo() == from + 1 || mHist[cturn - 1].getTo() == from - 1))) {
				++threatened[WHITE][mHist[cturn - 1].getTo()];
				possiblemoves[cmove] = move(from, mHist[cturn - 1].getTo() + NORTH, ENPASSANT);
				++cmove;
			}
			if (!grid[from + NORTH]) {
				if (from > 15) { possiblemoves[cmove] = move(from, from + NORTH, STANDARD); }
				else { possiblemoves[cmove] = move(from, from + NORTH, QPROMOTE); }
				++cmove;
				if (from / WIDTH == 6 && !grid[from + 2 * NORTH]) {
					possiblemoves[cmove] = move(from, from + 2 * NORTH, DOUBLEPUSH);
					++cmove;
				}
			}
		}
		else {
			if (from % WIDTH) { ++threatened[WHITE][from + NORTH - 1]; }
			if (from % WIDTH != 7) { ++threatened[WHITE][from + NORTH + 1]; }
		}
		return;
	case KNIGHT:
		if (WHITE == turn) {
			if ((from + 10) % WIDTH > from % WIDTH && from < 54) {
				++threatened[WHITE][from + 10];
				if (grid[from + 10] <= 0) {
					if (!grid[from + 10]) { possiblemoves[cmove] = move(from, from + 10, STANDARD); }
					else { possiblemoves[cmove] = move(from, from + 10, CAPTURE); }
					++cmove;
				}
			}
			if ((from + 17) % WIDTH > from % WIDTH && from < 47) {
				++threatened[WHITE][from + 17];
				if (grid[from + 17] <= 0) {
					if (!grid[from + 17]) { possiblemoves[cmove] = move(from, from + 17, STANDARD); }
					else { possiblemoves[cmove] = move(from, from + 17, CAPTURE); }
					++cmove;
				}
			}
			if ((from - 10) % WIDTH < from % WIDTH && from >= 10) {
				++threatened[WHITE][from - 10];
				if (grid[from - 10] <= 0) {
					if (!grid[from - 10]) { possiblemoves[cmove] = move(from, from - 10, STANDARD); }
					else { possiblemoves[cmove] = move(from, from - 10, CAPTURE); }
					++cmove;
				}
			}
			if ((from - 17) % WIDTH < from % WIDTH && from >= 17) {
				++threatened[WHITE][from - 17];
				if (grid[from - 17] <= 0) {
					if (!grid[from - 17]) { possiblemoves[cmove] = move(from, from - 17, STANDARD); }
					else { possiblemoves[cmove] = move(from, from - 17, CAPTURE); }
					++cmove;
				}
			}
			if ((from + 6) % WIDTH < from % WIDTH && from < 58) {
				++threatened[WHITE][from + 6];
				if (grid[from + 6] <= 0) {
					if (!grid[from + 6]) { possiblemoves[cmove] = move(from, from + 6, STANDARD); }
					else { possiblemoves[cmove] = move(from, from + 6, CAPTURE); }
					++cmove;
				}
			}
			if ((from + 15) % WIDTH < from % WIDTH && from < 49) {
				++threatened[WHITE][from + 15];
				if (grid[from + 15] <= 0) {
					if (!grid[from + 15]) { possiblemoves[cmove] = move(from, from + 15, STANDARD); }
					else { possiblemoves[cmove] = move(from, from + 15, CAPTURE); }
					++cmove;
				}
			}
			if ((from - 6) % WIDTH > from % WIDTH && from >= 6) {
				++threatened[WHITE][from - 6];
				if (grid[from - 6] <= 0) {
					if (!grid[from - 6]) { possiblemoves[cmove] = move(from, from - 6, STANDARD); }
					else { possiblemoves[cmove] = move(from, from - 6, CAPTURE); }
					++cmove;
				}
			}
			if ((from - 15) % WIDTH > from % WIDTH && from >= 15) {
				++threatened[WHITE][from - 15];
				if (grid[from - 15] <= 0) {
					if (!grid[from - 15]) { possiblemoves[cmove] = move(from, from - 15, STANDARD); }
					else { possiblemoves[cmove] = move(from, from - 15, CAPTURE); }
					++cmove;
				}
			}
		}
		else {
			if ((from + 10) % WIDTH > from % WIDTH && from < 54) { ++threatened[WHITE][from + 10]; }
			if ((from + 17) % WIDTH > from % WIDTH && from < 47) { ++threatened[WHITE][from + 17]; }
			if ((from - 10) % WIDTH < from % WIDTH && from >= 10) { ++threatened[WHITE][from - 10]; }
			if ((from - 17) % WIDTH < from % WIDTH && from >= 17) { ++threatened[WHITE][from - 17]; }
			if ((from + 6) % WIDTH < from % WIDTH && from < 58) { ++threatened[WHITE][from + 6]; }
			if ((from + 15) % WIDTH < from % WIDTH && from < 49) { ++threatened[WHITE][from + 15]; }
			if ((from - 6) % WIDTH > from % WIDTH && from >= 6) { ++threatened[WHITE][from - 6]; }
			if ((from - 15) % WIDTH > from % WIDTH && from >= 15) { ++threatened[WHITE][from - 15]; }
		}
		return;
	case QUEEN:
		if (WHITE == turn) {
			for (i = from + NORTHEAST; i % WIDTH > from % WIDTH; i += NORTHEAST) {
				if (i < 0) { break; }
				++threatened[WHITE][i];
				if (!grid[i]) {
					possiblemoves[cmove] = move(from, i, STANDARD);
					++cmove;
				}
				else {
					if (grid[i] < 0) {
						possiblemoves[cmove] = move(from, i, CAPTURE);
						++cmove;
					}
					break;
				}
			}
			for (i = from + NORTHWEST; i % WIDTH < from % WIDTH; i += NORTHWEST) {
				if (i < 0) { break; }
				++threatened[WHITE][i];
				if (!grid[i]) {
					possiblemoves[cmove] = move(from, i, STANDARD);
					++cmove;
				}
				else {
					if (grid[i] < 0) {
						possiblemoves[cmove] = move(from, i, CAPTURE);
						++cmove;
					}
					break;
				}
			}
			for (i = from + SOUTHEAST; i % WIDTH > from % WIDTH; i += SOUTHEAST) {
				if (i >= SPACES) { break; }
				++threatened[WHITE][i];
				if (!grid[i]) {
					possiblemoves[cmove] = move(from, i, STANDARD);
					++cmove;
				}
				else {
					if (grid[i] < 0) {
						possiblemoves[cmove] = move(from, i, CAPTURE);
						++cmove;
					}
					break;
				}
			}
			for (i = from + SOUTHWEST; i % WIDTH < from % WIDTH; i += SOUTHWEST) {
				if (i >= SPACES) { break; }
				++threatened[WHITE][i];
				if (!grid[i]) {
					possiblemoves[cmove] = move(from, i, STANDARD);
					++cmove;
				}
				else {
					if (grid[i] < 0) {
						possiblemoves[cmove] = move(from, i, CAPTURE);
						++cmove;
					}
					break;
				}
			}
			for (i = from + NORTH; i >= 0; i += NORTH) {
				++threatened[WHITE][i];
				if (!grid[i]) {
					possiblemoves[cmove] = move(from, i, STANDARD);
					++cmove;
				}
				else {
					if (grid[i] < 0) {
						possiblemoves[cmove] = move(from, i, CAPTURE);
						++cmove;
					}
					break;
				}
			}
			for (i = from + SOUTH; i < SPACES; i += SOUTH) {
				++threatened[WHITE][i];
				if (!grid[i]) {
					possiblemoves[cmove] = move(from, i, STANDARD);
					++cmove;
				}
				else {
					if (grid[i] < 0) {
						possiblemoves[cmove] = move(from, i, CAPTURE);
						++cmove;
					}
					break;
				}
			}
			for (i = from + EAST; i % WIDTH; i += EAST) {
				++threatened[WHITE][i];
				if (!grid[i]) {
					possiblemoves[cmove] = move(from, i, STANDARD);
					++cmove;
				}
				else {
					if (grid[i] < 0) {
						possiblemoves[cmove] = move(from, i, CAPTURE);
						++cmove;
					}
					break;
				}
			}
			for (i = from + WEST; i % WIDTH != 7; i += WEST) {
				if (i < 0) { break; }
				++threatened[WHITE][i];
				if (!grid[i]) {
					possiblemoves[cmove] = move(from, i, STANDARD);
					++cmove;
				}
				else {
					if (grid[i] < 0) {
						possiblemoves[cmove] = move(from, i, CAPTURE);
						++cmove;
					}
					break;
				}
			}
		}
		else {
			for (i = from + NORTHEAST; i % WIDTH > from % WIDTH; i += NORTHEAST) {
				if (i < 0) { break; }
				++threatened[WHITE][i];
				if (grid[i]) { break; }
			}
			for (i = from + NORTHWEST; i % WIDTH < from % WIDTH; i += NORTHWEST) {
				if (i < 0) { break; }
				++threatened[WHITE][i];
				if (grid[i]) { break; }
			}
			for (i = from + SOUTHEAST; i % WIDTH > from % WIDTH; i += SOUTHEAST) {
				if (i >= SPACES) { break; }
				++threatened[WHITE][i];
				if (grid[i]) { break; }
			}
			for (i = from + SOUTHWEST; i % WIDTH < from % WIDTH; i += SOUTHWEST) {
				if (i >= SPACES) { break; }
				++threatened[WHITE][i];
				if (grid[i]) { break; }
			}
			for (i = from + NORTH; i >= 0; i += NORTH) {
				++threatened[WHITE][i];
				if (grid[i]) { break; }
			}
			for (i = from + SOUTH; i < SPACES; i += SOUTH) {
				++threatened[WHITE][i];
				if (grid[i]) { break; }
			}
			for (i = from + EAST; i % WIDTH; i += EAST) {
				++threatened[WHITE][i];
				if (grid[i]) { break; }
			}
			for (i = from + WEST; i % WIDTH != WIDTH - 1; i += WEST) {
				if (i < 0) { break; }
				++threatened[WHITE][i];
				if (grid[i]) { break; }
			}
		}
		return;
	case ROOK:
		if (WHITE == turn) {
			for (i = from + NORTH; i >= 0; i += NORTH) {
				++threatened[WHITE][i];
				if (!grid[i]) {
					possiblemoves[cmove] = move(from, i, STANDARD);
					++cmove;
				}
				else {
					if (grid[i] < 0) {
						possiblemoves[cmove] = move(from, i, CAPTURE);
						++cmove;
					}
					break;
				}
			}
			for (i = from + SOUTH; i < SPACES; i += SOUTH) {
				++threatened[WHITE][i];
				if (!grid[i]) {
					possiblemoves[cmove] = move(from, i, STANDARD);
					++cmove;
				}
				else {
					if (grid[i] < 0) {
						possiblemoves[cmove] = move(from, i, CAPTURE);
						++cmove;
					}
					break;
				}
			}
			for (i = from + EAST; i % WIDTH; i += EAST) {
				if (i >= SPACES) { break; }
				++threatened[WHITE][i];
				if (!grid[i]) {
					possiblemoves[cmove] = move(from, i, STANDARD);
					++cmove;
				}
				else {
					if (grid[i] < 0) {
						possiblemoves[cmove] = move(from, i, CAPTURE);
						++cmove;
					}
					break;
				}
			}
			for (i = from + WEST; i % WIDTH != 7; i += WEST) {
				if (i < 0) { break; }
				++threatened[WHITE][i];
				if (!grid[i]) {
					possiblemoves[cmove] = move(from, i, STANDARD);
					++cmove;
				}
				else {
					if (grid[i] < 0) {
						possiblemoves[cmove] = move(from, i, CAPTURE);
						++cmove;
					}
					break;
				}
			}
		}
		else {
			for (i = from + NORTH; i >= 0; i += NORTH) {
				if (i < 0) { break; }
				++threatened[WHITE][i];
				if (grid[i]) { break; }
			}
			for (i = from + SOUTH; i < SPACES; i += SOUTH) {
				if (i > -SPACES) { break; }
				++threatened[WHITE][i];
				if (grid[i]) { break; }
			}
			for (i = from + EAST; i % WIDTH; i += EAST) {
				if (i > -SPACES) { break; }
				++threatened[WHITE][i];
				if (grid[i]) { break; }
			}
			for (i = from + WEST; i % WIDTH != 7; i += WEST) {
				if (i < 0) { break; }
				++threatened[WHITE][i];
				if (grid[i]) { break; }
			}
		}
		return;
	case BISHOP:
		if (WHITE == turn) {
			for (i = from + NORTHEAST; i % WIDTH > from % WIDTH; i += NORTHEAST) {
				if (i < 0) { break; }
				++threatened[WHITE][i];
				if (!grid[i]) {
					possiblemoves[cmove] = move(from, i, STANDARD);
					++cmove;
				}
				else {
					if (grid[i] < 0) {
						possiblemoves[cmove] = move(from, i, CAPTURE);
						++cmove;
					}
					break;
				}
			}
			for (i = from + NORTHWEST; i % WIDTH < from % WIDTH; i += NORTHWEST) {
				if (i < 0) { break; }
				++threatened[WHITE][i];
				if (!grid[i]) {
					possiblemoves[cmove] = move(from, i, STANDARD);
					++cmove;
				}
				else {
					if (grid[i] < 0) {
						possiblemoves[cmove] = move(from, i, CAPTURE);
						++cmove;
					}
					break;
				}
			}
			for (i = from + SOUTHEAST; i % WIDTH > from % WIDTH; i += SOUTHEAST) {
				if (i >= SPACES) { break; }
				++threatened[WHITE][i];
				if (!grid[i]) {
					possiblemoves[cmove] = move(from, i, STANDARD);
					++cmove;
				}
				else {
					if (grid[i] < 0) {
						possiblemoves[cmove] = move(from, i, CAPTURE);
						++cmove;
					}
					break;
				}
			}
			for (i = from + SOUTHWEST; i % WIDTH < from % WIDTH; i += SOUTHWEST) {
				if (i >= SPACES) { break; }
				++threatened[WHITE][i];
				if (!grid[i]) {
					possiblemoves[cmove] = move(from, i, STANDARD);
					++cmove;
				}
				else {
					if (grid[i] < 0) {
						possiblemoves[cmove] = move(from, i, CAPTURE);
						++cmove;
					}
					break;
				}
			}
		}
		else {
			for (i = from + NORTHEAST; i % WIDTH > from % WIDTH; i += NORTHEAST) {
				if (i < 0) { break; }
				++threatened[WHITE][i];
				if (grid[i]) { break; }
			}
			for (i = from + NORTHWEST; i % WIDTH < from % WIDTH; i += NORTHWEST) {
				if (i < 0) { break; }
				++threatened[WHITE][i];
				if (grid[i]) { break; }
			}
			for (i = from + SOUTHEAST; i % WIDTH > from % WIDTH; i += SOUTHEAST) {
				if (i >= SPACES) { break; }
				++threatened[WHITE][i];
				if (grid[i]) { break; }
			}
			for (i = from + SOUTHWEST; i % WIDTH < from % WIDTH; i += SOUTHWEST) {
				if (i >= SPACES) { break; }
				++threatened[WHITE][i];
				if (grid[i]) { break; }
			}
		}
		return;
	case -KING:
		if (BLACK == turn) {
			if ((from + 9) % WIDTH > from % WIDTH && from < 55) {
				++threatened[BLACK][from + 9];
				if (!threatened[WHITE][from + 9] && grid[from + 9] >= 0) {
					if (!grid[from + 9]) { possiblemoves[cmove] = move(from, from + 9, STANDARD); }
					else { possiblemoves[cmove] = move(from, from + 9, CAPTURE); }
					++cmove;
				}
			}
			if ((from + 1) % WIDTH > from % WIDTH) {
				++threatened[BLACK][from + 1];
				if (!threatened[WHITE][from + 1] && grid[from + 1] >= 0) {
					if (!grid[from + 1]) { possiblemoves[cmove] = move(from, from + 1, STANDARD); }
					else { possiblemoves[cmove] = move(from, from + 1, CAPTURE); }
					++cmove;
				}
			}
			if ((from - 9) % WIDTH < from % WIDTH && from >= 9) {
				++threatened[BLACK][from - 9];
				if (!threatened[WHITE][from - 9] && grid[from - 9] >= 0) {
					if (!grid[from - 9]) { possiblemoves[cmove] = move(from, from - 9, STANDARD); }
					else { possiblemoves[cmove] = move(from, from - 9, CAPTURE); }
					++cmove;
				}
			}
			if ((from - 1) % WIDTH < from % WIDTH && from >= 1) {
				++threatened[BLACK][from - 1];
				if (!threatened[WHITE][from - 1] && grid[from - 1] >= 0) {
					if (!grid[from - 1]) { possiblemoves[cmove] = move(from, from - 1, STANDARD); }
					else { possiblemoves[cmove] = move(from, from - 1, CAPTURE); }
					++cmove;
				}
			}
			if ((from + 7) % WIDTH < from % WIDTH && from < 57) {
				++threatened[BLACK][from + 7];
				if (!threatened[WHITE][from + 7] && grid[from + 7] >= 0) {
					if (!grid[from + 7]) { possiblemoves[cmove] = move(from, from + 7, STANDARD); }
					else { possiblemoves[cmove] = move(from, from + 7, CAPTURE); }
					++cmove;
				}
			}
			if (from + 8 < SPACES) {
				++threatened[BLACK][from + 8];
				if (!threatened[WHITE][from + 8] && grid[from + 8] >= 0) {
					if (!grid[from + 8]) { possiblemoves[cmove] = move(from, from + 8, STANDARD); }
					else { possiblemoves[cmove] = move(from, from + 8, CAPTURE); }
					++cmove;
				}
			}
			if ((from - 7) % WIDTH > from % WIDTH && from >= 7) {
				++threatened[BLACK][from - 7];
				if (!threatened[WHITE][from - 7] && grid[from - 7] >= 0) {
					if (!grid[from - 7]) { possiblemoves[cmove] = move(from, from - 7, STANDARD); }
					else { possiblemoves[cmove] = move(from, from - 7, CAPTURE); }
					++cmove;
				}
			}
			if (from >= 8) {
				++threatened[BLACK][from - 8];
				if (!threatened[WHITE][from - 8] && grid[from - 8] >= 0) {
					if (!grid[from - 8]) { possiblemoves[cmove] = move(from, from - 8, STANDARD); }
					else { possiblemoves[cmove] = move(from, from - 8, CAPTURE); }
					++cmove;
				}
			}
			if (from == 4 && !grid[from + 1] && !grid[from + 2] && !threatened[WHITE][from] && !threatened[WHITE][from + 1] && !threatened[WHITE][from + 2]) {
				for (i = 0; i < cturn; ++i) {
					if (mHist[i].getFrom() == from || mHist[i].getFrom() == from + 3 || mHist[i].getTo() == from + 3) { break; }
				}
				if (i == cturn) {
					possiblemoves[cmove] = move(from, from + 2, KCASTLE);
				}
			}
			if (from == 4 && !grid[from - 1] && !grid[from - 2] && !grid[from - 3] && !threatened[WHITE][from] && !threatened[WHITE][from - 1] && !threatened[WHITE][from - 2] && !threatened[WHITE][from - 3]) {
				for (i = 0; i < cturn; ++i) {
					if (mHist[i].getFrom() == from || mHist[i].getFrom() == from - 4 || mHist[i].getTo() == from - 4) { break; }
				}
				if (i == cturn) {
					possiblemoves[cmove] = move(from, from + 2, QCASTLE);
				}
			}
		}
		else {
			if ((from + 9) % WIDTH > from % WIDTH && from < 55) { ++threatened[BLACK][from + 9]; }
			if ((from + 1) % WIDTH > from % WIDTH) { ++threatened[BLACK][from + 1]; }
			if ((from - 9) % WIDTH < from % WIDTH && from > 8) { ++threatened[BLACK][from - 9]; }
			if ((from - 1) % WIDTH < from % WIDTH && from > 0) { ++threatened[BLACK][from - 1]; }
			if ((from + 7) % WIDTH < from % WIDTH && from < 57) { ++threatened[BLACK][from + 7]; }
			if (from < 56) { ++threatened[BLACK][from + 8]; }
			if ((from - 7) % WIDTH > from % WIDTH && from > 6) { ++threatened[BLACK][from - 7]; }
			if (from >= 8) { ++threatened[BLACK][from - 8]; }
		}
		return;
	case -PAWN:
		if (BLACK == turn) {
			if (from % WIDTH) {
				++threatened[BLACK][from + SOUTH - 1];
				if (grid[from + SOUTH - 1] > 0) {
					if (from + SOUTH < 56) { possiblemoves[cmove] = move(from, from + SOUTH - 1, CAPTURE); }
					else { possiblemoves[cmove] = move(from, from + SOUTH - 1, QPROMOTEC); }
					++cmove;
				}
			}
			if (from % WIDTH != 7) {
				++threatened[BLACK][from + SOUTH + 1];
				if (grid[from + SOUTH + 1] > 0) {
					if (from + SOUTH < 56) { possiblemoves[cmove] = move(from, from + SOUTH + 1, CAPTURE); }
					else { possiblemoves[cmove] = move(from, from + SOUTH + 1, QPROMOTEC); }
					++cmove;
				}
			}
			if (mHist[cturn - 1].getFlags() == DOUBLEPUSH && ((mHist[cturn - 1].getTo() == from + 1 || mHist[cturn - 1].getTo() == from - 1))) {
				++threatened[BLACK][mHist[cturn - 1].getTo()];
				possiblemoves[cmove] = move(from, mHist[cturn - 1].getTo() + SOUTH, ENPASSANT);
				++cmove;
			}
			if (!grid[from + SOUTH]) {
				if (from + SOUTH < 56) { possiblemoves[cmove] = move(from, from + SOUTH, STANDARD); }
				else { possiblemoves[cmove] = move(from, from + SOUTH, QPROMOTE); }
				++cmove;
				if (from < 16 && !grid[from + 2 * SOUTH]) {
					possiblemoves[cmove] = move(from, from + 2 * SOUTH, DOUBLEPUSH);
					++cmove;
				}
			}
		}
		else {
			if (from % WIDTH) { ++threatened[BLACK][from + SOUTH - 1]; }
			if (from % WIDTH != WIDTH - 1) { ++threatened[BLACK][from + SOUTH + 1]; }
		}
		return;
	case -KNIGHT:
		if (BLACK == turn) {
			if ((from + 10) % WIDTH > from % WIDTH && from < 54) {
				++threatened[BLACK][from + 10];
				if (grid[from + 10] >= 0) {
					if (!grid[from + 10]) { possiblemoves[cmove] = move(from, from + 10, STANDARD); }
					else { possiblemoves[cmove] = move(from, from + 10, CAPTURE); }
					++cmove;
				}
			}
			if ((from + 17) % WIDTH > from % WIDTH && from < 47) {
				++threatened[BLACK][from + 17];
				if (grid[from + 17] >= 0) {
					if (!grid[from + 17]) { possiblemoves[cmove] = move(from, from + 17, STANDARD); }
					else { possiblemoves[cmove] = move(from, from + 17, CAPTURE); }
					++cmove;
				}
			}
			if ((from - 10) % WIDTH < from % WIDTH && from > 9) {
				++threatened[BLACK][from - 10];
				if (grid[from - 10] >= 0) {
					if (!grid[from - 10]) { possiblemoves[cmove] = move(from, from - 10, STANDARD); }
					else { possiblemoves[cmove] = move(from, from - 10, CAPTURE); }
					++cmove;
				}
			}
			if ((from - 17) % WIDTH < from % WIDTH && from > 16) {
				++threatened[BLACK][from - 17];
				if (grid[from - 17] >= 0) {
					if (!grid[from - 17]) { possiblemoves[cmove] = move(from, from - 17, STANDARD); }
					else { possiblemoves[cmove] = move(from, from - 17, CAPTURE); }
					++cmove;
				}
			}
			if ((from + 6) % WIDTH < from % WIDTH && from < 58) {
				++threatened[BLACK][from + 6];
				if (grid[from + 6] >= 0) {
					if (!grid[from + 6]) { possiblemoves[cmove] = move(from, from + 6, STANDARD); }
					else { possiblemoves[cmove] = move(from, from + 6, CAPTURE); }
					++cmove;
				}
			}
			if ((from + 15) % WIDTH < from % WIDTH && from < 49) {
				++threatened[BLACK][from + 15];
				if (grid[from + 15] >= 0) {
					if (!grid[from + 15]) { possiblemoves[cmove] = move(from, from + 15, STANDARD); }
					else { possiblemoves[cmove] = move(from, from + 15, CAPTURE); }
					++cmove;
				}
			}
			if ((from - 6) % WIDTH > from % WIDTH && from > 5) {
				++threatened[BLACK][from - 6];
				if (grid[from - 6] >= 0) {
					if (!grid[from - 6]) { possiblemoves[cmove] = move(from, from - 6, STANDARD); }
					else { possiblemoves[cmove] = move(from, from - 6, CAPTURE); }
					++cmove;
				}
			}
			if ((from - 15) % WIDTH > from % WIDTH && from > 14) {
				++threatened[BLACK][from - 15];
				if (grid[from - 15] >= 0) {
					if (!grid[from - 15]) { possiblemoves[cmove] = move(from, from - 15, STANDARD); }
					else { possiblemoves[cmove] = move(from, from - 15, CAPTURE); }
					++cmove;
				}
			}
		}
		else {
			if ((from + 10) % WIDTH > from % WIDTH && from < 54) { ++threatened[BLACK][from + 10]; }
			if ((from + 17) % WIDTH > from % WIDTH && from < 47) { ++threatened[BLACK][from + 17]; }
			if ((from - 10) % WIDTH < from % WIDTH && from > 9) { ++threatened[BLACK][from - 10]; }
			if ((from - 17) % WIDTH < from % WIDTH && from > 16) { ++threatened[BLACK][from - 17]; }
			if ((from + 6) % WIDTH < from % WIDTH && from < 58) { ++threatened[BLACK][from + 6]; }
			if ((from + 15) % WIDTH < from % WIDTH && from < 49) { ++threatened[BLACK][from + 15]; }
			if ((from - 6) % WIDTH > from % WIDTH && from > 5) { ++threatened[BLACK][from - 6]; }
			if ((from - 15) % WIDTH > from % WIDTH && from > 14) { ++threatened[BLACK][from - 15]; }
		}
		return;
	case -QUEEN:
		if (BLACK == turn) {
			for (i = from + NORTHEAST; i % WIDTH > from % WIDTH; i += NORTHEAST) {
				if (i < 0) { break; }
				++threatened[BLACK][i];
				if (!grid[i]) {
					possiblemoves[cmove] = move(from, i, STANDARD);
					++cmove;
				}
				else {
					if (grid[i] > 0) {
						possiblemoves[cmove] = move(from, i, CAPTURE);
						++cmove;
					}
					break;
				}
			}
			for (i = from + NORTHWEST; i % WIDTH < from % WIDTH; i += NORTHWEST) {
				if (i < 0) { break; }
				++threatened[BLACK][i];
				if (!grid[i]) {
					possiblemoves[cmove] = move(from, i, STANDARD);
					++cmove;
				}
				else {
					if (grid[i] > 0) {
						possiblemoves[cmove] = move(from, i, CAPTURE);
						++cmove;
					}
					break;
				}
			}
			for (i = from + SOUTHEAST; i % WIDTH > from % WIDTH; i += SOUTHEAST) {
				if (i >= SPACES) { break; }
				++threatened[BLACK][i];
				if (!grid[i]) {
					possiblemoves[cmove] = move(from, i, STANDARD);
					++cmove;
				}
				else {
					if (grid[i] > 0) {
						possiblemoves[cmove] = move(from, i, CAPTURE);
						++cmove;
					}
					break;
				}
			}
			for (i = from + SOUTHWEST; i % WIDTH < from % WIDTH; i += SOUTHWEST) {
				if (i >= SPACES) { break; }
				++threatened[BLACK][i];
				if (!grid[i]) {
					possiblemoves[cmove] = move(from, i, STANDARD);
					++cmove;
				}
				else {
					if (grid[i] > 0) {
						possiblemoves[cmove] = move(from, i, CAPTURE);
						++cmove;
					}
					break;
				}
			}
			for (i = from + NORTH; i >= 0; i += NORTH) {
				++threatened[BLACK][i];
				if (!grid[i]) {
					possiblemoves[cmove] = move(from, i, STANDARD);
					++cmove;
				}
				else {
					if (grid[i] > 0) {
						possiblemoves[cmove] = move(from, i, CAPTURE);
						++cmove;
					}
					break;
				}
			}
			for (i = from + SOUTH; i < SPACES; i += SOUTH) {
				++threatened[BLACK][i];
				if (!grid[i]) {
					possiblemoves[cmove] = move(from, i, STANDARD);
					++cmove;
				}
				else {
					if (grid[i] > 0) {
						possiblemoves[cmove] = move(from, i, CAPTURE);
						++cmove;
					}
					break;
				}
			}
			for (i = from + EAST; i % WIDTH; i += EAST) {
				++threatened[BLACK][i];
				if (!grid[i]) {
					possiblemoves[cmove] = move(from, i, STANDARD);
					++cmove;
				}
				else {
					if (grid[i] > 0) {
						possiblemoves[cmove] = move(from, i, CAPTURE);
						++cmove;
					}
					break;
				}
			}
			for (i = from + WEST; i % WIDTH != 7; i += WEST) {
				if (i < 0) { break; }
				++threatened[BLACK][i];
				if (!grid[i]) {
					possiblemoves[cmove] = move(from, i, STANDARD);
					++cmove;
				}
				else {
					if (grid[i] > 0) {
						possiblemoves[cmove] = move(from, i, CAPTURE);
						++cmove;
					}
					break;
				}
			}
		}
		else {
			for (i = from + NORTHEAST; i % WIDTH > from % WIDTH; i += NORTHEAST) {
				if (i < 0) { break; }
				++threatened[BLACK][i];
				if (grid[i]) { break; }
			}
			for (i = from + NORTHWEST; i % WIDTH < from % WIDTH; i += NORTHWEST) {
				if (i < 0) { break; }
				++threatened[BLACK][i];
				if (grid[i]) { break; }
			}
			for (i = from + SOUTHEAST; i % WIDTH > from % WIDTH; i += SOUTHEAST) {
				if (i >= SPACES) { break; }
				++threatened[BLACK][i];
				if (grid[i]) { break; }
			}
			for (i = from + SOUTHWEST; i % WIDTH < from % WIDTH; i += SOUTHWEST) {
				if (i >= SPACES) { break; }
				++threatened[BLACK][i];
				if (grid[i]) { break; }
			}
			for (i = from + NORTH; i >= 0; i += NORTH) {
				++threatened[BLACK][i];
				if (grid[i]) { break; }
			}
			for (i = from + SOUTH; i < SPACES; i += SOUTH) {
				++threatened[BLACK][i];
				if (grid[i]) { break; }
			}
			for (i = from + EAST; i % WIDTH; i += EAST) {
				++threatened[BLACK][i];
				if (grid[i]) { break; }
			}
			for (i = from + WEST; i % WIDTH != 7; i += WEST) {
				if (i < 0) { break; }
				++threatened[BLACK][i];
				if (grid[i]) { break; }
			}
		}
		return;
	case -ROOK:
		if (BLACK == turn) {
			for (i = from + NORTH; i >= 0; i += NORTH) {
				if (i < 0) { break; }
				++threatened[BLACK][i];
				if (!grid[i]) {
					possiblemoves[cmove] = move(from, i, STANDARD);
					++cmove;
				}
				else {
					if (grid[i] > 0) {
						possiblemoves[cmove] = move(from, i, CAPTURE);
						++cmove;
					}
					break;
				}
			}
			for (i = from + SOUTH; i < SPACES; i += SOUTH) {
				++threatened[BLACK][i];
				if (!grid[i]) {
					possiblemoves[cmove] = move(from, i, STANDARD);
					++cmove;
				}
				else {
					if (grid[i] > 0) {
						possiblemoves[cmove] = move(from, i, CAPTURE);
						++cmove;
					}
					break;
				}
			}
			for (i = from + EAST; i % WIDTH; i += EAST) {
				++threatened[BLACK][i];
				if (!grid[i]) {
					possiblemoves[cmove] = move(from, i, STANDARD);
					++cmove;
				}
				else {
					if (grid[i] > 0) {
						possiblemoves[cmove] = move(from, i, CAPTURE);
						++cmove;
					}
					break;
				}
			}
			for (i = from + WEST; i % WIDTH != 7; i += WEST) {
				if (i < 0) { break; }
				++threatened[BLACK][i];
				if (!grid[i]) {
					possiblemoves[cmove] = move(from, i, STANDARD);
					++cmove;
				}
				else {
					if (grid[i] > 0) {
						possiblemoves[cmove] = move(from, i, CAPTURE);
						++cmove;
					}
					break;
				}
			}
		}
		else {
			for (i = from + NORTH; i > 0; i += NORTH) {
				++threatened[BLACK][i];
				if (grid[i]) { break; }
			}
			for (i = from + SOUTH; i < SPACES; i += SOUTH) {
				++threatened[BLACK][i];
				if (grid[i]) { break; }
			}
			for (i = from + EAST; i % WIDTH; i += EAST) {
				++threatened[BLACK][i];
				if (grid[i]) { break; }
			}
			for (i = from + WEST; i % WIDTH != 7; i += WEST) {
				if (i < 0) { break; }
				++threatened[BLACK][i];
				if (grid[i]) { break; }
			}
		}
		return;
	case -BISHOP:
		if (BLACK == turn) {
			for (i = from + NORTHEAST; i % WIDTH > from % WIDTH; i += NORTHEAST) {
				if (i < 0) { break; }
				++threatened[BLACK][i];
				if (!grid[i]) {
					possiblemoves[cmove] = move(from, i, STANDARD);
					++cmove;
				}
				else {
					if (grid[i] > 0) {
						possiblemoves[cmove] = move(from, i, CAPTURE);
						++cmove;
					}
					break;
				}
			}
			for (i = from + NORTHWEST; i % WIDTH < from % WIDTH; i += NORTHWEST) {
				if (i < 0) { break; }
				++threatened[BLACK][i];
				if (!grid[i]) {
					possiblemoves[cmove] = move(from, i, STANDARD);
					++cmove;
				}
				else {
					if (grid[i] > 0) {
						possiblemoves[cmove] = move(from, i, CAPTURE);
						++cmove;
					}
					break;
				}
			}
			for (i = from + SOUTHEAST; i % WIDTH > from % WIDTH; i += SOUTHEAST) {
				if (i >= SPACES) { break; }
				++threatened[BLACK][i];
				if (!grid[i]) {
					possiblemoves[cmove] = move(from, i, STANDARD);
					++cmove;
				}
				else {
					if (grid[i] > 0) {
						possiblemoves[cmove] = move(from, i, CAPTURE);
						++cmove;
					}
					break;
				}
			}
			for (i = from + SOUTHWEST; i % WIDTH < from % WIDTH; i += SOUTHWEST) {
				if (i >= SPACES) { break; }
				++threatened[BLACK][i];
				if (!grid[i]) {
					possiblemoves[cmove] = move(from, i, STANDARD);
					++cmove;
				}
				else {
					if (grid[i] > 0) {
						possiblemoves[cmove] = move(from, i, CAPTURE);
						++cmove;
					}
					break;
				}
			}
		}
		else {
			for (i = from + NORTHEAST; i % WIDTH > from % WIDTH; i += NORTHEAST) {
				if (i < 0) { break; }
				++threatened[BLACK][i];
				if (grid[i]) { break; }
			}
			for (i = from + NORTHWEST; i % WIDTH < from % WIDTH; i += NORTHWEST) {
				if (i < 0) { break; }
				++threatened[BLACK][i];
				if (grid[i]) { break; }
			}
			for (i = from + SOUTHEAST; i % WIDTH > from % WIDTH; i += SOUTHEAST) {
				if (i >= SPACES) { break; }
				++threatened[BLACK][i];
				if (grid[i]) { break; }
			}
			for (i = from + SOUTHWEST; i % WIDTH < from % WIDTH; i += SOUTHWEST) {
				if (i >= SPACES) { break; }
				++threatened[BLACK][i];
				if (grid[i]) { break; }
			}
		}
		return;
	}
}